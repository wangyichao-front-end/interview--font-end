<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    隐式转换就是自动转换，通常发生在一些数学运算中
    //与隐式类型转换相反，强制类型转换需要手动进行，在 JavaScript 中，强制类型转换主要是通过调用全局函数来实现的
    //例如 Number()、Boolean()、parseInt()、parseFloat() 等。
    1.只有 null undefined '' NaN 0 false 这几个是 false，其他的情况都是 true，比如 {} , []。
    2.undefined 转换为数字是 NaN，['5']首先会变成 '5', 然后再变成数字 5


    js中的数据类型隐式转换的三种情况
    转换为boolean类型
    转换为number类型
    转换为string类型
    复杂对象如何转换为简单值

    一个复杂对象在转为基础类型的时候会调用ToPrimitive(hint)方法来指定其目标类型。
    如果传入的hint值为number,那么就先调用对象的valueOf()方法，调用完valueOf()方法后，如果返回的是原始值，则结束ToPrimitive操作，
    如果返回的不是原始值，则继续调用对象的toString()方法，调用完toString()方法之后如果返回的是一个原始值，则结束ToPrimitive操作，
    如果返回的还是复杂值，则抛出异常。如果传入的hint值为string，则先调用toString()方法，再调用valueOf()方法，其余的过程一样。

    使用 == 比较中的规则：
    1.NaN和其他任何类型比较永远返回false（包括和他自己）
    2.Boolean 和其他任何类型比较，Boolean 首先被转换为 Number 类型。
    3.String和Number比较，先将String转换为Number类型。
    4.null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false。
    5.复杂数据类型（[]，{}）在隐式转换时会先转成String，然后再转成Number运算
    6.如果两边类型不同，则两边都尝试转成number类型。对于引用类型，先调用valueOf(),如果能转成数字，则进行比较。
    不能转成数字就调用toString()方法转成字符串。

    js中最大的整数为： 2^53 - 1; 其中 1 位符号位 11 位指数位 52 位尾数位，使用 52 位表示一个数的整数部分

    <script>
        1 * undefined //  NaN, undefined 转换为数字是 NaN
        1 - null // 1,  首先把 null 转换为数字 0， 然后执行 1 - 0
        123 + {}  // 123[object Object]
        123 + [] //123
        Number({}) //NaN
        NaN == NaN // false
        null == undefined // true
        // [] == ![] //true
        // [undefined] == false //true
        console.log(1 + 'a');
        console.log(true + 1);
    </script>
</body>

</html>